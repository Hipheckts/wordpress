#!/usr/bin/env python

from __future__ import print_function
import argparse
import datetime
import getpass
import json
import os
import os.path
import pipes
import re
import socket
import subprocess
import sys
import termcolor

class Evolve:
    def __init__(self):
        # handle arguments & flags
        parser = argparse.ArgumentParser(prog='./bin/evolve')
        parser.add_argument('stage', help='environment against which to run given action')
        parser.add_argument('action', help='action to run against given stage')
        parser.add_argument('-v','--verbose', action='count', help='increase verbosity')
        parser.add_argument('-e','--extra-vars', action='append', help='provide key=value pairs or JSON document')
        self.arguments = parser.parse_args()
        self._extra_vars()

        self.announce_verbose('Parsed args:', self.arguments)

        # determine paths
        self.working_path = os.getcwd()
        self.ansible_path = os.path.join(self.working_path, 'lib/ansible')
        self.actions_path = os.path.join(os.path.dirname(__file__), '../lib/actions')

        self.announce_verbose('Paths:', {
            'working_path': self.working_path,
            'ansible_path': self.ansible_path,
            'actions_path': self.actions_path,
        })

        # expose positional arguments for simpler dependency injection
        self.stage = self.arguments.stage
        self.action = self.arguments.action

        self.announce('Loading "%s" action in the "%s" stage' % (self.action, self.stage))
        try:
            action_module = self.import_action(self.action)
        except ImportError as err:
            print(termcolor.colored('Unknown action "%s"' % self.action, 'red'), file=sys.stderr)
            sys.exit(1)

        # install galaxy roles
        # todo: bypass --force unless roles are older than X?
        self.call(['ansible-galaxy', 'install', '-r', os.path.join(self.ansible_path, 'galaxy.yml'), '--force'])

        # import and instantiate action
        try:
            self.init_action(action_module)
        except Exception as err:
            print(termcolor.colored('The "%s" action failed: %s' % (self.action, err), 'red'), file=sys.stderr)
            self.log_action(False, self.action)
        else:
            self.log_action(True, self.action)

    def announce(self, message):
        '''
        Prints a colored announcement across the terminal.
        '''
        print(termcolor.colored("\n! %s" % message, 'green'))

    def announce_verbose(self, label, *args):
        if self.arguments.verbose > 3:
            print(termcolor.colored(label, 'magenta'), *args)

    def call(self, *args):
        '''
        Prints and runs a command, or piped series of commands, inheriting standard input/output and returning after completion.
        Throws subprocess.CalledProcessError if returncode was nonzero.
        '''
        command = self._normalize_commands(args)
        print(termcolor.colored("$ %s\n" % command, 'yellow'))
        return subprocess.check_call(command, shell=True)

    def bg_call(self, *args):
        '''
        Runs a command, or piped series of commands, ignoring standard input/output and returning a returncode after completion.
        '''
        command = self._normalize_commands(args)
        self.announce_verbose('Background process:', termcolor.colored("$ %s" % command, 'yellow'))

        proc = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output = proc.communicate()

        result = { 'stdout': output[0], 'returncode': proc.returncode }
        self.announce_verbose('Background result:', result)

        return result

    def _normalize_commands(self, args):
        '''
        Normalizes and escapes one or more commands (as lists), piping each into the command following it.
        '''
        groups = []

        for command in args:
            # remove any None args
            command = filter(lambda a: a != None, command)
            # quote each arg for shell metacharacters
            command = map(pipes.quote, command)
            # flatten args to string command
            groups.append(' '.join(command))

        # flatten commands to pipe chain
        return ' | '.join(groups)

    def single_input(self, prompt, cb):
        '''
        Prompts for a single line of input, validating with a given callback.
        '''
        built_prompt = "\n? %s: " % prompt
        while True:
            result = raw_input(termcolor.colored(built_prompt, 'cyan'))

            try:
                if cb(result):
                    return result
            except:
                pass

    def multi_input(self, prompt, choices):
        '''
        Prompts from a given list of choices.
        '''
        built_prompt = termcolor.colored("\n? %s:\n" % prompt, 'cyan')

        for i, choice in enumerate(choices):
            choices[i] = choice.lower()
            built_prompt += " %s %s\n" % (
                termcolor.colored("[%i]" % (i+1), 'grey', 'on_cyan'),
                termcolor.colored(choice.lower(), 'cyan')
            )

        built_prompt += termcolor.colored("> ", 'cyan')

        while True:
            result = raw_input(built_prompt)

            try:
                test_index = int(result)
                if 1 <= test_index <= len(choices):
                    return choices[test_index-1]
            except (ValueError, IndexError, TypeError):
                pass

            if result.lower() in choices:
                return result.lower()

    def password_input(self, prompt):
        '''
        Prompts for a password (which is not shown).
        '''
        built_prompt = "\n\a? %s: " % prompt
        return getpass.getpass(termcolor.colored(built_prompt, 'white', 'on_blue'))

    def _extra_vars(self):
        if self.arguments.extra_vars:
            extra_vars = {}
            for pair in self.arguments.extra_vars:
                m = re.match(r'^([\w-]+)=([^=]+)$', pair)
                if m:
                    extra_vars[m.group(1)] = m.group(2)
                else:
                    try:
                        parsed = json.loads(pair)
                    except ValueError as err:
                        raise ValueError('%s: %s' % (err, pair))
                    extra_vars.update(parsed)
            self.arguments.extra_vars = extra_vars

    def import_action(self, action):
        '''
        Imports an module (adding actions path to system paths if necessary) and returns it.
        '''
        if self.actions_path not in sys.path:
            sys.path.append(self.actions_path)
        return __import__(action)

    def init_action(self, action_module):
        '''
        Initializes an ActionClass from the given module.
        '''
        action_module.ActionClass(self)

    def playbook(self, playbook, extra_vars=None, extra_args=None):
        '''
        Runs an ansible playbook, with optional json encoded extra_vars and optional extra arguments.
        '''
        call_args = ['ansible-playbook']

        # add extra_vars encoded as json
        if extra_vars is not None:
            call_args += ['-e', json.dumps(extra_vars)]

        # add extra args...
        if extra_args is not None:
            # append, if a scalar string
            if isinstance(extra_args, basestring):
                call_args.append(extra_args)
            # otherwise add as a list-like
            else:
                call_args += extra_args

        # append playbook filepath
        call_args.append(os.path.join(self.ansible_path, playbook))

        self.call(call_args)

    def log_action(self, success, message):
        '''
        Writes a log entry to a remote server, via a specialized ansible playbook.
        '''
        local_user = getpass.getuser()
        local_host = socket.gethostname()
        local_time = datetime.datetime.today().strftime('%c')
        status = 'Success' if success else 'Failure'

        extra_vars = {
            'stage': self.stage,
            'log_message': '\t'.join([local_time, local_user, message, status])
        }

        try:
            self.playbook('log.yml', extra_vars)
        except subprocess.CalledProcessError as err:
            print(termcolor.colored('Failed to log action to remote: %s' % err, 'red'), file=sys.stderr)

if __name__ == "__main__":
    Evolve()
